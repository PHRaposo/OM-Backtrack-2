; OM File Header - Saved 2024/12/30 09:36:24
; (7.05 :patc (om-make-point 102 101) (om-make-point 13 26) (om-make-point 1331 706) "" 183 0 nil "2024/12/30 09:36:20")
; End File Header
(in-package :om)(load-lib-for (quote ("OM-Backtrack")))(setf *om-current-persistent* (om-load-patch1 "00c-choice-point" (quote ((let ((box (om-load-seqbox "SEQUENCE 2" (quote sequence) (quote ((om-load-inputfun (quote input-funbox) "something" "PATCH" nil) (om-load-inputfun (quote input-funbox) "more things" "OPPATCH" nil))) (om-make-point 1163 261) nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "EVENP 2" (quote evenp) (quote ((om-load-inputfun (quote input-funbox) "NUM" "NUM" nil))) (om-make-point 1124 136) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ASSERT!" (quote assert!) (quote ((om-load-inputfun (quote input-funbox) "boolean" "X" nil))) (om-make-point 1119 181) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 16" (quote t) (quote nil) (om-make-point 1258 16) (om-make-point 27 30) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 15" (quote t) (quote nil) (om-make-point 1224 6) (om-make-point 27 30) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 14" (quote t) (quote nil) (om-make-point 1191 4) (om-make-point 27 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 1155 12) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "EITHER 4" (quote either) (quote ((om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil) (om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil) (om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil) (om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil))) (om-make-point 1185 61) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ALL-VALUES 2" (quote all-values) (quote ((om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil))) (om-make-point 1171 315) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 249 30) (quote "Screamer primitives EITHER and FAIL.") "" (om-make-point 254 373) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FAIL" (quote fail) (quote nil) (om-make-point 390 407) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "EITHER 3" (quote either) (quote nil) (om-make-point 274 405) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 2" (om-make-point 607 255) (quote "In this second example, we have applied a simple constraint to the values$returned by EITHER [open the evenp patch to see how it is done]. Basically,$if the value is even, the result is true. Otherwise it calls the Screamer primitive$FAIL. Finally, using all-values we get only even numbers [0 2].$$Optionally, we can use the method apply-cont to apply any function or patch$in lambda mode to the values. Internally, if a constraint applied with apply-cont$returns false, it automatically calls the Screamer primitive function FAIL.$$We can also use the Screamer ASSERT! macro [implemented here as a method] to $assert constraints to variables.$$Note that, in order to get the correct results, we need to set the EITHER box to$eval-once mode when using apply or assert! combined with sequence.") "" (om-make-point 709 422) nil (om-make-color 0 0 0) (om-make-font "Verdana" 14.0D0 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 529 51) (quote "<<< In this example, we have used ALL-VALUES to return the results of$EITHER [0 1 2 3], with no constraints.") "" (om-make-point 133 544) nil (om-make-color 0 0 0) (om-make-font "Verdana" 14.0D0 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 593 272) (quote "Nondeterministic Lisp$$At its core, Screamer adds only two new constructs to Common Lisp.$The macro EITHER [here implemented as an OM method] nondeterministically$evaluates one of an arbitrary number of subexpressions and returns the result.$Operationally, this can be viewed as introducing a choice-point. The expression $EITHER [e1 e2 ... en] first evaluates e1 and returns its result. If the computation$fails, either during the evaluation of e1 or during subsequent computation using$the value produced by e1 - the computation backtracks to evaluate e2 and return$its value instead. Failures are introduced by calling the function FAIL, the second$primitive construct provided by Screamer. Repeated failures cause the evaluation$of subsequent subexpressions in the dynamically nested EITHER expression until$no further subexpressions remain. Choice-points are dynamically nested.$Failing to a choice-point whose alternatives are exhausted will propagate to the$next most recent choice-point.") "" (om-make-point 23 31) nil (om-make-color 0 0 0) (om-make-font "Verdana" 14.0D0 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 10" (quote t) (quote nil) (om-make-point 2362/3 10) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 11" (quote t) (quote nil) (om-make-point 2446/3 2) (om-make-point 27 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 12" (quote t) (quote nil) (om-make-point 2560/3 4) (om-make-point 27 30) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "EITHER 2" (quote either) (quote ((om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil) (om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil) (om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil) (om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil))) (om-make-point 2467/3 448/9) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 13" (quote t) (quote nil) (om-make-point 2656/3 12) (om-make-point 27 30) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "evenp" (om-load-patch-abs1 "evenp" (quote ((let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 101 173) (om-make-point 24 30) (quote t) "t" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "EVENP" (quote evenp) (quote ((om-load-inputfun (quote input-funbox) "NUM" "NUM" nil))) (om-make-point 44 113) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 87 324) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 89 9) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FAIL" (quote fail) (quote nil) (om-make-point 163 129) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 51 228) (om-make-point 121 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 1 0 nil 0) (5 0 2 0 nil 0) (1 0 5 0 nil 0) (0 0 5 1 nil 0) (4 0 5 2 nil 0))) 7.04 nil "" (om-make-point 348 152) (om-make-point 266 414)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 2176/3 1006/9) nil nil "l" "evenp"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "APPLY" (quote apply) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "ARG" "ARG" nil))) (om-make-point 2308/3 1834/9) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 2353/3 1231/9) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "SEQUENCE" (quote sequence) (quote ((om-load-inputfun (quote input-funbox) "something" "PATCH" nil) (om-load-inputfun (quote input-funbox) "more things" "OPPATCH" nil))) (om-make-point 2401/3 2275/9) nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "EVENP" (quote evenp) (quote ((om-load-inputfun (quote input-funbox) "NUM" "NUM" nil))) (om-make-point 954 148) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ALL-VALUES" (quote all-values) (quote ((om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil))) (om-make-point 975 315) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "EITHER 2" (quote either) (quote ((om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil) (om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil) (om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil) (om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil))) (om-make-point 1000 71) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 970 22) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 1006 14) (om-make-point 27 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 1039 16) (om-make-point 27 30) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 1073 35) (om-make-point 27 30) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "APPLY-CONT" (quote apply-cont) (quote ((om-load-inputfun (quote input-funbox) "List of constraints in lambda-mode" "FUNS" nil) (om-load-inputfun (quote input-funbox) "Variables" "VAR" nil))) (om-make-point 974 221) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ALL-VALUES 6" (quote all-values) (quote ((om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil))) (om-make-point 807 318) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 9" (quote t) (quote nil) (om-make-point 144 390) (om-make-point 27 30) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ALL-VALUES 5" (quote all-values) (quote ((om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil))) (om-make-point 59 519) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 8" (quote t) (quote nil) (om-make-point 108 383) (om-make-point 27 30) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 7" (quote t) (quote nil) (om-make-point 75 381) (om-make-point 27 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 6" (quote t) (quote nil) (om-make-point 31 386) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "EITHER" (quote either) (quote ((om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil) (om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil) (om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil) (om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil))) (om-make-point 71 438) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (7 0 0 1 nil 0) (7 0 1 0 nil 0) (1 0 2 0 nil 0) (6 0 7 0 nil 0) (5 0 7 1 nil 0) (4 0 7 2 nil 0) (3 0 7 3 nil 0) (0 1 8 0 nil 0) (15 0 18 0 nil 0) (16 0 18 1 nil 0) (17 0 18 2 nil 0) (19 0 18 3 nil 0) (20 0 21 0 nil 0) (22 0 21 1 nil 0) (18 0 22 0 nil 0) (21 0 23 0 nil 0) (18 0 23 1 nil 0) (31 0 25 0 nil 0) (27 0 26 0 nil 0) (28 0 26 1 nil 0) (29 0 26 2 nil 0) (30 0 26 3 nil 0) (24 0 31 0 nil 0) (26 0 31 1 nil 0) (23 1 32 0 nil 0) (38 0 34 0 nil 0) (37 0 38 0 nil 0) (36 0 38 1 nil 0) (35 0 38 2 nil 0) (33 0 38 3 nil 0))) nil 7.04))
